# Support Learning: Onboarding, Everboarding, and Release Readiness

> A product-centric approach to building scalable support readiness at GitHub.

## TL;DR

This document outlines how I would ramp into Support Learning, learn the product and support environment deeply, and then build a clear, maintainable learning structure for support engineers. My focus would be on understanding the work first, defining role-based skills second, and then designing onboarding, everboarding, and release readiness enablement that is grounded in real support needs. My approach treats enablement as a product in its own right: identify real problems (skills gaps), define measurable outcomes, iteratively deliver solutions, and validate impact.

The first tangible outcome would be a release readiness enablement package designed to help engineers understand upcoming changes, find answers quickly, and validate readiness.

## Why this README exists

This is meant to show how I think about technical enablement, how I ramp into a new organization, and how I would sequence meaningful impact without rushing to solutions. It is intentionally written as a working document, not a finished strategy. The goal is to demonstrate judgment, structure, and approach rather than to prescribe outcomes before learning.

I assume that many strong practices already exist at GitHub. My intent would be to understand whatâ€™s working, identify where learning can reduce friction or cognitive load, and then make targeted improvements that scale alongside a rapidly evolving product and team.

## How I approach technical enablement

I design technical enablement with a product mindset, applying instructional design thinking to ensure learning drives real performance outcomes. Learning is most effective when it is:

* Grounded in real work â€“ closely aligned to the tasks support engineers perform.
* Outcome-focused â€“ designed to improve measurable performance, not just deliver content.
* Maintainable and scalable â€“ adaptable as SaaS products change rapidly.

My design approach starts with **backwards design**. I begin by understanding what a support engineer needs to be able to do in order to be successful, then work backwards to define skills, practice opportunities, and learning assets that support those outcomes. This keeps learning focused on performance rather than content volume.

When building content, I follow an **adopt, adapt, create** model. I first look for existing documentation, PRDs, release notes, or knowledge base content that can be reused. If something exists but isnâ€™t usable in a support context, I adapt it. Only when a clear gap remains do I create new content. This helps learning scale without becoming brittle or expensive to maintain.

I also design content with longevity in mind. Time-intensive formats like live training or video are reserved for evergreen concepts, while fast-changing information is delivered through written guides, labs, or knowledge base entries that are easy to update. When UI walkthroughs are helpful, I use lightweight AI-assisted tools to create and refresh them quickly.

## The three learning flows

Rather than treating enablement as a single program, I think in terms of three recurring flows that together cover the full support engineer lifecycle. These flows share the same skill framework and content library but serve different moments of need.

### ðŸŒ± Onboarding

Onboarding is focused on helping new support engineers become effective as quickly and confidently as possible. The work here is about clarity and structure rather than volume.

Key elements:

* Clear skill expectations for the first 30/60/90 days
* Curated learning paths mapped to those skills
* Practice with realistic scenarios before handling complex tickets
* Lightweight readiness checks to confirm progress

### ðŸ”„ Everboarding

Everboarding supports engineers as products, workflows, and AI capabilities evolve. This is how engineers stay aligned with changing product and support realities.

Key elements:

* Skill refresh and validation
* New workflow and AI adoption
* Peer-generated content from experienced engineers
* Targeted learning tied to observed support trends

### ðŸš€ Release readiness

Release readiness connects learning directly to product change. This is about providing a coherent view of product changes, their implications for support, and practical guidance to maintain high performance..

Key elements:

* Whatâ€™s changing and why it matters
* Where to find updated answers quickly
* Scenario-based guidance for new behaviors
* A simple knowledge check to validate readiness

## First 30 days: learn and build context

In the first month, my priority would be to understand the work of support engineers and to upskill myself on GitHub so that I can design learning from a place of real context.

I would spend time shadowing support engineers across tiers, reviewing common ticket types, and understanding where engineers feel friction or uncertainty. In parallel, I would focus on my own product enablement, expanding my knowledge of GitHub and learning existing internal tools so I can speak the same technical language as the teams Iâ€™m supporting.

By the end of the first 30 days, I would expect to have:

* A clear picture of support roles, responsibilities, and workflows
* An understanding of current learning assets and gaps
* Baseline knowledge of key metrics (ramp time, TTR, escalations, CSAT)
* Early hypotheses about where learning could most reduce friction

## Days 31â€“60: define skills, curate resources, and plan delivery

Once I understand the environment, the next step would be to define what *good* looks like for each support role.

I would work with Support leaders and experienced engineers to map the skills required for different support tiers. From there, I would curate existing documentation, knowledge base articles, labs, and learning resources that already support those skills, and clearly identify where gaps exist.

This results in two concrete outputs:

* A role-based skill map for support engineers
* A curated content library mapped to those skills

At that point, I would create a delivery plan that separates work into onboarding and everboarding tracks, with clear sequencing and ownership. This is also when I would plan the first release readiness deliverable, using the skills map as the foundation rather than starting from scratch.

## Days 61â€“90: deliver release readiness and establish patterns

The first major visible deliverable would be a **release readiness enablement package for all support engineers** aligned to an upcoming product release.

Rather than focusing on a single feature, this package would cover:

* Whatâ€™s changing across the release
* Which changes matter to which support tiers
* Where to find updated documentation and answers
* How to practice or validate readiness

This would include a lightweight knowledge check to confirm readiness. At the same time, I would document patterns and templates so release readiness becomes a repeatable motion rather than a one-off effort.

## Using AI thoughtfully

I see AI as a way to increase efficiency across the entire content development lifecycle. I would use it to analyze support tickets and trends, validate content before SME review, and generate learning in multiple modalities more quickly. Over time, I would also explore AI-assisted feedback on support responses as a lightweight way to assess skill development.

The goal is not to automate learning, but to make high-quality learning easier to build, maintain, and evolve.

## How I measure impact

Learning only matters if it changes outcomes. Early on, I would focus on understanding existing metrics such as time to resolution, onboarding ramp time, escalation rates, and customer satisfaction.

As the enablement program matures, I would expect to see reduced ramp time for new engineers, faster resolution for common issues, fewer escalations after releases, and improved CSAT. I woul also track system health metrics like content freshness and update cycle time to ensure learning stays sustainable.

## What I would focus on in the first year

After validating the release readiness pilot, I would focus on refreshing onboarding with clear skill milestones, establishing a lightweight readiness or certification model, and building a just-in-time knowledge library that support engineers can rely on in the flow of work. Over time, I would deepen partnerships with Product and Engineering so learning is consistently built into how changes ship.

## Open questions

* Where do support leaders feel the most pain today?
* How do different support tiers define readiness?
* What metrics matter most right now?
