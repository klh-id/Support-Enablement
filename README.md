# GitHub Support Enablement

_Onboarding, everboarding, and continuous readiness: A product-centric approach to scalable support enablement at GitHub._

## TL;DR

> [!NOTE]
> Live slide deck: https://klh-id.github.io/Support-Enablement/

This document outlines how I would approach my onboarding journey at GitHub. My focus would be on understanding the work first, defining role-based skills second, and then designing onboarding, everboarding, and continuous readiness enablement that is grounded in real support needs. My approach treats enablement as a product in its own right: identify real problems (skills gaps), define measurable outcomes, iteratively deliver solutions, and validate impact.

The first tangible outcome would be a lightweight, repeatable readiness pattern that helps support engineers stay oriented as changes ship, find answers quickly, and validate understanding.

## Why this README exists

This is meant to show how I think about technical enablement, how I ramp into a new organization, and how I would sequence meaningful impact without rushing to solutions. It is intentionally written as a working document, not a finished strategy. The goal is to demonstrate judgment, structure, and approach rather than to prescribe outcomes before learning.

I assume that many strong practices already exist at GitHub. My intent would be to understand what‚Äôs working, identify where learning can reduce friction or cognitive load, and then make targeted improvements that scale alongside a rapidly evolving product and team.

## How I approach technical enablement

I design technical enablement with a product mindset, applying instructional design thinking to ensure learning drives real performance outcomes. Learning is most effective when it is:

* Grounded in real work ‚Äì closely aligned to the tasks support engineers perform.
* Outcome-focused ‚Äì designed to improve measurable performance, not just deliver content.
* Maintainable and scalable ‚Äì adaptable as SaaS products change rapidly.

My design approach starts with **backwards design**. I begin by understanding what a support engineer needs to be able to do in order to be successful, then work backwards to define skills, practice opportunities, and learning assets that support those outcomes. This keeps learning focused on performance rather than content volume.

When building content, I follow an **adopt, adapt, create** model. I first look for existing documentation, PRDs, release notes, or knowledge base content that can be reused. If something exists but isn‚Äôt usable in a support context, I adapt it. Only when a clear gap remains do I create new content. This helps learning scale without becoming brittle or expensive to maintain.

I also design content with longevity in mind. Time-intensive formats like live training or video are reserved for evergreen concepts, while fast-changing information is delivered through written guides, labs, or knowledge base entries that are easy to update. When UI walkthroughs are helpful, I use lightweight AI-assisted tools to create and refresh them quickly.

## Enablement in a continuous delivery environment

GitHub evolves continuously, so enablement needs to do the same. I would design enablement to align with how change already flows through GitHub: releases, documentation updates, and evolving workflows.

My goal would not be to introduce new processes, but to leverage existing GitHub-native processes so enablement stays close to the source of truth and requires less manual coordination. This keeps learning lightweight, asynchronous, and easier to sustain over time.

## Enablement considerations unique to Support

Support enablement requires a broader and deeper skill mix than many technical roles. Support engineers must understand how the product should work, how to troubleshoot when it doesn‚Äôt, and how to make good decisions under uncertainty. They also serve as a primary touchpoint for customers, which means every interaction reflects GitHub‚Äôs brand, values, and quality bar.

Because of this, effective enablement develops four overlapping skill areas:

* Product knowledge: deep understanding of expected behavior, edge cases, and known limitations
* Problem solving and judgment: diagnosing issues, testing hypotheses, and knowing when to escalate
* Resource fluency: quickly finding, validating, and applying the right documentation or internal knowledge
* Communication and brand representation: explaining complex ideas clearly, empathetically, and in a way that reflects GitHub‚Äôs voice

Effective support enablement blends technical depth, decision-making practice, and communication skills so engineers can help customers even when answers aren‚Äôt obvious.

## The three learning flows

Rather than treating enablement as a single program, I think in terms of three complementary flows that together cover the full support engineer lifecycle. These flows share the same skill framework and content library but serve different moments of need.

### üå± Onboarding

Onboarding focuses on helping new support engineers become effective quickly and confidently. The emphasis is on clarity, sequencing, and practice rather than volume.

Key elements include clear skill expectations for the first 30/60/90 days, curated learning paths, realistic practice scenarios, and informal assessments to confirm progress.

### üîÑ Everboarding

Everboarding focuses on sustained skill development as products, workflows, and tools evolve. It addresses deeper capability gaps that emerge over time, informed by support trends and recurring questions.

This is where engineers refine mental models, adopt new workflows, and strengthen judgment in complex or ambiguous cases.

### üöÄ Continuous readiness

Continuous readiness provides a lightweight awareness layer that helps engineers understand what just changed, why it matters, and where to look for answers. It is designed to reduce surprise and uncertainty without requiring full retraining for every update.

Rather than a single event, readiness becomes a repeatable motion that aligns with how GitHub ships.

## First 30 days: learn the work, the product, and how change ships

In the first month, my focus would be on understanding how support engineers actually do their work at GitHub and how product change flows through the organization.

I would spend time shadowing support engineers across tiers, reviewing common ticket types, and observing moments of friction, uncertainty, or escalation. In parallel, I would focus on my own product enablement ‚Äî learning GitHub, internal tools, and how teams ship, document, and communicate product changes.

This includes building context around:

* how product changes are deployed and surfaced internally
* how documentation and the Changelog are updated
* where support engineers currently discover change
* which changes create the most downstream impact for support

By the end of the first 30 days, I would expect to have:

* a clear understanding of support workflows and roles
* visibility into existing learning assets and how they‚Äôre used
* baseline knowledge of key metrics (ramp time, TTR, escalations, CSAT)
* early hypotheses about where enablement could reduce friction or cognitive load

## Days 31‚Äì60: define role-based skills and map existing enablement

With foundational context in place, the next phase would focus on defining what ‚Äúgood‚Äù looks like for each support tier and mapping learning to real work.

I would partner with support leaders and experienced engineers to draft a role-based skill map that includes not only product knowledge, but troubleshooting, judgment, and communication skills. I would then map existing documentation, knowledge base articles, labs, and training resources to those skills to understand where learning already exists and where gaps remain.

By the end of 60 days, I would expect to have:

* a draft skill model grounded in real support workflows
* a mapped view of existing learning resources
* identified high-friction gaps worth addressing first
* shared alignment with support leaders on priorities

## Days 61‚Äì90: validate gaps and define the enablement roadmap

In the final phase, I would validate the skill and content maps through real support scenarios, ticket reviews, and engineer feedback to ensure they reflect day-to-day needs. My goal would be to leave the first 90 days with an actionable roadmap** for enablement.

By the end of this phase, I would expect to deliver:

* a validated role-based skill map for support engineers
* a content map showing coverage, gaps, and duplication
* a prioritized list of enablement opportunities
* a proposed phased roadmap for onboarding, everboarding, and continuous readiness
* recommendations for when (and how) to introduce a centralized enablement hub

## Using AI thoughtfully

I see AI as a way to increase efficiency across the entire content development lifecycle. I would use it to analyze support tickets and trends, validate content before SME review, and generate learning in multiple modalities more quickly. Over time, I would also explore AI-assisted feedback on support responses as a lightweight way to assess skill development.

The goal is not to automate learning, but to make high-quality learning easier to build, maintain, and evolve.

## How I measure impact

Learning only matters if it changes outcomes. Early on, I would focus on understanding existing metrics such as time to resolution, onboarding ramp time, escalation rates, and customer satisfaction.

As the enablement program matures, I would expect to see reduced ramp time for new engineers, faster resolution for common issues, fewer escalations after releases, and improved CSAT. I woul also track system health metrics like content freshness and update cycle time to ensure learning stays sustainable.

## What I would focus on in the first year

After validating the release readiness pilot, I would focus on refreshing onboarding with clear skill milestones, establishing a lightweight readiness or certification model, and building a just-in-time knowledge library that support engineers can rely on in the flow of work. Over time, I would deepen partnerships with Product and Engineering so learning is consistently built into how changes ship.

## Open questions

* Where do support leaders feel the most pain today?
* How do different support tiers define readiness?
* What metrics matter most right now?
